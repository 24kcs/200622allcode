<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>玉树临风美少年，揽镜自顾夜不眠 </title>
</head>

<body>
  <script type="text/javascript">

    // Object.create(prototype, [descriptors])
    // Object.create 方法可以以指定对象为原型创建新的对象，同时可以为新的对象设置属性, 并对属性进行描述
    // - value : 指定值
    // - writable : 标识当前属性值是否是可修改的, 默认为 false
    // - configurable：标识当前属性是否可以被删除 默认为 false
    // - enumerable：标识当前属性是否能用for in 枚举 默认为 false
    // - get:   当获取当前属性时的回调函数
    // - set:   当设置当前属性时

    // var obj1 = {
    //   name: '卡卡西',
    //   age: 20
    // }
    // Object.create()方法可以创建一个新的对象,新的对象obj2是创建对象的时候传入的obj1的子对象(obj1和obj2是继承关系,obj1是父级对象,obj2是子级对象)

    // 1. 通过Object.create方法创建一个obj2的对象,让obj2继承自obj1
    // var obj2 = Object.create(obj1);
    // console.log(obj2)
    // console.log(obj2.name)
    // console.log(obj2.age)


    // 2. 通过Object.create方法创建一个obj2的对象,让obj2继承自obj1,同时使用配置对象的方式,让obj2添加新的属性
    // var obj2 = Object.create(obj1, {
    //   // 为obj2对象添加了gender这个属性
    //   gender: {
    //     value: '男', // 设置gender属性的默认值是: 男
    //     writable: false, // 设置当前的gender属性的值是否可以改变,默认是false,不能改变
    //     configurable: false, // 设置当前的gender属性是否可以被删除,默认是false,不能被删除
    //     enumerable:true, // 设置当前的gender属性是否可以被枚举遍历,默认是false,不能被枚举/遍历
    //   }
    // })
    // console.log(obj2)
    // // 修改属性值
    // // obj2.gender = '女'
    // // console.log(obj2)
    // // 删除gender属性
    // // delete obj2.gender
    // // console.log(obj2)
    // // 遍历当前obj2对象中的所有的属性(遍历---枚举)
    // for(var key in obj2){
    //   console.log(key)
    // }

    // 问题:什么时候用Object.create()方法?
    // 如果希望当前的对象和其他的对象是继承关系,同时当前的对象还需要添加一些可控制的属性
    var obj1 = {
      name: '卡卡西',
      age: 20
    }
    var obj2 = Object.create(obj1, {
      // 为obj2对象添加了gender这个属性
      gender: {
        // value: '男', // 设置gender属性的默认值是: 男
        // writable: false, // 设置当前的gender属性的值是否可以改变,默认是false,不能改变
        configurable: false, // 设置当前的gender属性是否可以被删除,默认是false,不能被删除
        enumerable:true, // 设置当前的gender属性是否可以被枚举遍历,默认是false,不能被枚举/遍历
        // 访问器--读取: 如果外部通过obj2.gender这种方式来获取当前的这个gender属性值的时候,会自动的进入到get方法中
        get:function(){
          return '女'
        },
        // 设置值的时候,外部如果通过obj2.gender='值'这种方式的时候,就是在给gender属性赋值,就会自动的进入到set中
        set:function(val){
          console.log('来啦,多玩一会'+val)
        }
      }
    })
    console.log(obj2)
    console.log(obj2.gender)
    obj2.gender = '男'
    console.log(obj2)















    // 继承:


    // 面向对象是一种编程思想,提出需求,抽象出对象,通过对象调用属性或者方法,实现相关的需求,注重的是结果
    // 面向对象的特性: 封装,继承,多态,(抽象性)
    // 封装:把一个值放在一个变量中,把很多的变量放在一个对象中,把很多重复的代码放在一个方法中,把很多相同或者类似功能的方法或者属性放在对象中,把很多的函数或者对象放在一个js文件中
    // 继承:类与类之间的概念(js中没有类的概念,js中是通过构造函数来模拟类的概念的,在ES6中才引入了class,通过class也可以创建对象),ES6之前,都是通过构造函数来创建对象,因为,有很多对象他们之间有一些相同的属性或者方法,所以,可以使用继承的方式来实现
    // 多态:js几乎不说多态

    /*

        狗:
        特征: 名字,年龄,颜色
        行为: 吃,睡觉,叫

        大黄狗:
        特征: 名字,年龄,颜色
        行为: 吃,睡觉,叫, 咬人
        |
        |
        |

        狗:
        属性:名字,年龄,颜色
        方法:吃,睡觉

        大黄狗:
        属性: 名字,年龄,颜色
        方法: 吃,睡觉, 咬人

    */

    // 构造函数
    // function Dog(name, color) {
    //   this.name = name;
    //   this.color = color;
    // }
    // // 原型对象添加方法
    // Dog.prototype.eat = function () {
    //   console.log('大骨头真好吃,汪汪...')
    // };
    // Dog.prototype.sleep = function () {
    //   console.log('梦到了强哥,真香...')
    // };

    // // 构造函数
    // function BigYellowDog(name, color) {
    //   this.name = name;
    //   this.color = color;
    // };
    // // 当前的BigYellowDog就继承了Dog了
    // BigYellowDog.prototype = new Dog('大黄', '黄色');
    // var bigYellow = new BigYellowDog('小黄', '绿色');
    // bigYellow.eat()
    // bigYellow.sleep()

    // 继承: 可以实现数据共享,节省内存空间


    // 继承的方式: 改变原型实现继承/借用构造函数实现继承/组合继承/拷贝继承(浅拷贝和深拷贝(自己实现/插件:lodash插件---js库))

    // jQuery----js库中一种









  </script>
</body>

</html>